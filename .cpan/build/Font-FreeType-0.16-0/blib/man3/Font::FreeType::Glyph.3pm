.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Font::FreeType::Glyph 3"
.TH Font::FreeType::Glyph 3 2020-05-11 "perl v5.38.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
Font::FreeType::Glyph \- glyphs from font typefaces loaded from Font::FreeType
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 1
\&    use Font::FreeType;
\&
\&    my $freetype = Font::FreeType\->new;
\&    my $face = $freetype\->face(\*(AqVera.ttf\*(Aq);
\&    $face\->set_char_size(24, 24, 100, 100);
\&
\&    my $glyph = $face\->glyph_from_char(\*(AqA\*(Aq);
\&    my $glyph = $face\->glyph_from_char_code(65);
\&
\&    # Render into an array of strings, one byte per pixel.
\&    my ($bitmap, $left, $top) = $glyph\->bitmap;
\&
\&    # Read vector outline.
\&    $glyph\->outline_decompose(
\&        move_to => sub { ... },
\&        line_to => sub { ... },
\&        conic_to => sub { ... },
\&        cubic_to => sub { ... },
\&    );
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
This class represents an individual glyph (character image) loaded from
a font.  See Font::FreeType::Face for how to
obtain a glyph object, in particular the \f(CWglyph_from_char_code()\fR
and \f(CWglyph_from_char()\fR methods.
.PP
Things you an do with glyphs include:
.IP \(bu 4
Get metadata about the glyph, such as the size of its image and other
metrics.
.IP \(bu 4
Render a bitmap image of the glyph (if it's from a vector font) or
extract the existing bitmap (if it's from a bitmap font), using the
\&\f(CWbitmap()\fR method.
.IP \(bu 4
Extract a precise description of the lines and curves that make up
the glyph's outline, using the \f(CWoutline_decompose()\fR method.
.PP
For a detailed description of the meaning of glyph metrics, and
the structure of vectorial outlines,
see <http://freetype.sourceforge.net/freetype2/docs/glyphs/>
.SH METHODS
.IX Header "METHODS"
Unless otherwise stated, all methods will die if there is an error,
and the metrics are scaled to the size of the font face.
.IP bitmap([\fIrender-mode\fR]) 4
.IX Item "bitmap([render-mode])"
If the glyph is from a bitmap font, the bitmap image is returned.  If
it is from a vector font, then the outline is rendered into a bitmap
at the face's current size.
.Sp
Three values are returned: the bitmap itself, the number of pixels from
the origin to where the left of the area the bitmap describes, and the
number of pixels from the origin to the top of the area of the bitmap
(positive being up).
.Sp
The bitmap value is a reference to an array.  Each item in the array
represents a line of the bitmap, starting from the top.  Each item is
a string of bytes, with one byte representing one pixel of the image,
starting from the left.  A value of 0 indicates background (outside the
glyph outline), and 255 represents a point inside the outline.
.Sp
If antialiasing is used then shades of grey between 0 and 255 may occur.
Antialiasing is performed by default, but can be turned off by passing
the \f(CW\*(C`FT_RENDER_MODE_MONO\*(C'\fR option.
.Sp
The size of the bitmap can be obtained as follows:
.Sp
.Vb 3
\&    my ($bitmap, $left, $top) = $glyph\->bitmap;
\&    my $width = length $bitmap\->[0];
\&    my $height = @$bitmap;
.Ve
.Sp
The optional \f(CW\*(C`render_mode\*(C'\fR argument can be any one of the following:
.RS 4
.IP FT_RENDER_MODE_NORMAL 4
.IX Item "FT_RENDER_MODE_NORMAL"
The default.  Uses antialiasing.
.IP FT_RENDER_MODE_LIGHT 4
.IX Item "FT_RENDER_MODE_LIGHT"
Changes the hinting algorithm to make the glyph image closer to it's
real shape, but probably more fuzzy.
.Sp
Only available with Freetype version 2.1.4 or newer.
.IP FT_RENDER_MODE_MONO 4
.IX Item "FT_RENDER_MODE_MONO"
Render with antialiasing disabled.  Each pixel will be either 0 or 255.
.IP FT_RENDER_MODE_LCD 4
.IX Item "FT_RENDER_MODE_LCD"
Render in colour for an LCD display, with three times as many pixels
across the image as normal.  This mode probably won't work yet.
.Sp
Only available with Freetype version 2.1.3 or newer.
.IP FT_RENDER_MODE_LCD_V 4
.IX Item "FT_RENDER_MODE_LCD_V"
Render in colour for an LCD display, with three times as many rows
down the image as normal.  This mode probably won't work yet.
.Sp
Only available with Freetype version 2.1.3 or newer.
.RE
.RS 4
.RE
.IP bitmap_magick([\fIrender_mode\fR]) 4
.IX Item "bitmap_magick([render_mode])"
A simple wrapper around the \f(CWbitmap()\fR method.  Renders the bitmap as
normal and returns it as an Image::Magick object,
which can then be composited onto a larger bitmapped image, or manipulated
using any of the features available in Image::Magick.
.Sp
The image is in the 'gray' format, with a depth of 8 bits.
.Sp
The left and top distances in pixels are returned as well, in the
same way as for the \f(CWbitmap()\fR method.
.Sp
This method, particularly the use of the left and top offsets for
correct positioning of the bitmap, is demonstrated in the
\&\fImagick.pl\fR example program.
.IP bitmap_pgm([\fIrender_mode\fR]) 4
.IX Item "bitmap_pgm([render_mode])"
A simple wrapper around the \f(CWbitmap()\fR method.  It renders the bitmap
and constructs it into a PGM (portable grey-map) image file, which it
returns as a string.  The optional \fIrender-mode\fR is passed directly
to the \f(CWbitmap()\fR method.
.Sp
The PGM image returned is in the 'binary' format, with one byte per
pixel.  It is not an efficient format, but can be read by many image
manipulation programs.  For a detailed description of the format
see <http://netpbm.sourceforge.net/doc/pgm.html>
.Sp
The left and top distances in pixels are returned as well, in the
same way as for the \f(CWbitmap()\fR method.
.Sp
The \fIrender\-glyph.pl\fR example program uses this method.
.IP \fBchar_code()\fR 4
.IX Item "char_code()"
The character code (in Unicode) of the glyph.  Could potentially
return codes in other character sets if the font doesn't have a Unicode
character mapping, but most modern fonts do.
.IP \fBhas_outline()\fR 4
.IX Item "has_outline()"
True if the glyph has a vector outline, in which case it is safe to
call \f(CWoutline_decompose()\fR.  Otherwise, the glyph only has a bitmap
image.
.IP \fBheight()\fR 4
.IX Item "height()"
The height of the glyph.
.IP \fBhorizontal_advance()\fR 4
.IX Item "horizontal_advance()"
The distance from the origin of this glyph to the place where the next
glyph's origin should be.  Only applies to horizontal layouts.  Always
positive, so for right-to-left text (such as Hebrew) it should be
subtracted from the current glyph's position.
.IP \fBindex()\fR 4
.IX Item "index()"
The glyph's index number in the font.  This number is determined
by the FreeType library, and so isn't necessarily the same as any
special index number used by the font format.
.IP \fBleft_bearing()\fR 4
.IX Item "left_bearing()"
The left side bearing, which is the distance from the origin to
the left of the glyph image.  Usually positive for horizontal layouts
and negative for vertical ones.
.IP \fBload()\fR 4
.IX Item "load()"
Tell FreeType to load the glyph. There are very few reasons to use
this as it is called implicitly if needed, by most of the other methods.
.Sp
A few of these reasons include: timing or profiling tests of
FreeType, debugging FreeType via side effects of glyph loading
(by setting FT2_DEBUG).
.IP \fBname()\fR 4
.IX Item "name()"
The name of the glyph, if the font format supports glyph names,
otherwise \fIundef\fR.
.IP \fBoutline_bbox()\fR 4
.IX Item "outline_bbox()"
The bounding box of the glyph's outline.  This box will enclose all
the 'ink' that would be laid down if the outline were filled in.
It is calculated by studying each segment of the outline, so may
not be particularly efficient.
.Sp
The bounding box is returned as a list of four values, so the method
should be called as follows:
.Sp
.Vb 1
\&    my ($xmin, $ymin, $xmax, $ymax) = $glyph\->outline_bbox();
.Ve
.ie n .IP outline_decompose(\fR\fI%callbacks\fR\fI\fR) 4
.el .IP outline_decompose(\fR\f(CI%callbacks\fR\fI\fR) 4
.IX Item "outline_decompose(%callbacks)"
This method can be used to extract a description of the glyph's outline,
scaled to the face's current size.  It will die if the glyph doesn't
have an outline (if it comes from a bitmap font).
.Sp
Vector outlines of glyphs are represented by a sequence of operations.
Each operation can start a new curve (by moving the imaginary pen
position), or draw a line or curve from the current position of the
pen to a new position.  This Perl interface will walk through the outline
calling subroutines (through code references you supply) for each operation.
Arguments are passed to your subroutines as normal, in \f(CW@_\fR.
.Sp
Note: when you intend to extract the outline of a glyph, always
pass the \f(CW\*(C`FT_LOAD_NO_HINTING\*(C'\fR option when creating the face object,
or the hinting will distort the outline.
.Sp
The \fR\f(CI%callbacks\fR\fI\fR parameter should contain three or four of the
following keys, each with a reference to a \f(CW\*(C`sub\*(C'\fR as it's value.
The \f(CW\*(C`conic_to\*(C'\fR handler is optional, but the others are required.
.RS 4
.ie n .IP """move_to""" 4
.el .IP \f(CWmove_to\fR 4
.IX Item "move_to"
Move the pen to a new position, without adding anything to
the outline.  The first operation should always be \f(CW\*(C`move_to\*(C'\fR, but
characters with disconnected parts, such as \f(CW\*(C`i\*(C'\fR, might have several
of these.
.Sp
The \fIx\fR and \fIy\fR coordinates of the new pen position are supplied.
.ie n .IP """line_to""" 4
.el .IP \f(CWline_to\fR 4
.IX Item "line_to"
Move the pen to a new position, drawing a straight line from the
old position.
.Sp
The \fIx\fR and \fIy\fR coordinates of the new pen position are supplied.
Depending you how you are using this information you may have to keep
track of the previous position yourself.
.ie n .IP """conic_to""" 4
.el .IP \f(CWconic_to\fR 4
.IX Item "conic_to"
Move the pen to a new position, drawing a conic Bézier arc
(also known as a quadratic Bézier curve)
from the old position, using a single control point.
.Sp
If you don't supply a \f(CW\*(C`conic_to\*(C'\fR handler, all conic curves will be
automatically translated into cubic curves.
.Sp
The \fIx\fR and \fIy\fR coordinates of the new pen position are supplied,
followed by the \fIx\fR and \fIy\fR coordinates of the control point.
.ie n .IP """cubic_to""" 4
.el .IP \f(CWcubic_to\fR 4
.IX Item "cubic_to"
Move the pen to a new position, drawing a cubic Bézier arc
from the old position, using two control points.
.Sp
Cubic arcs are the ones produced in PostScript by the \f(CW\*(C`curveto\*(C'\fR
operator.
.Sp
The \fIx\fR and \fIy\fR coordinates of the new pen position are supplied,
followed by the \fIx\fR and \fIy\fR coordinates of the first control point,
then the same for the second control point.
.RE
.RS 4
.Sp
Note that TrueType fonts use conic curves and PostScript ones use
cubic curves.
.RE
.IP postscript([\fIfile-handle\fR]) 4
.IX Item "postscript([file-handle])"
Generate PostScript code to draw the outline of the glyph.  More precisely,
the output will construct a PostScript path for the outline, which can
then be filled in or stroked as you like.
.Sp
The \fIglyph\-to\-eps.pl\fR example program shows how to wrap the output
in enough extra code to generate a complete EPS file.
.Sp
If you pass a file-handle to this method then it will write the PostScript
code to that file, otherwise it will return it as a string.
.IP \fBright_bearing()\fR 4
.IX Item "right_bearing()"
The distance from the right edge of the glyph image to the place where
the origin of the next character should be (i.e., the end of the
advance width).  Only applies to horizontal layouts.  Usually positive.
.IP \fBsvg_path()\fR 4
.IX Item "svg_path()"
Turn the outline of the glyph into a string in a format suitable
for including in an SVG graphics file, as the \f(CW\*(C`d\*(C'\fR attribute of
a \f(CW\*(C`path\*(C'\fR element.  Note that because SVG's coordinate system has
its origin in the top left corner the outline will be upside down.
An SVG transformation can be used to flip it.
.Sp
The \fIglyph\-to\-svg.pl\fR example program shows how to wrap the output
in enough XML to generate a complete SVG file, and one way of
transforming the outline to be the right way up.
.Sp
If you pass a file-handle to this method then it will write the path
string to that file, otherwise it will return it as a string.
.IP \fBvertical_advance()\fR 4
.IX Item "vertical_advance()"
The distance from the origin of the current glyph to the place where
the next glyph's origin should be, moving down the page.  Only applies
to vertical layouts.  Always positive.
.IP \fBwidth()\fR 4
.IX Item "width()"
The width of the glyph.  This is the distance from the left
side to the right side, not the amount you should move along before
placing the next glyph when typesetting.  For that, see
the \f(CWhorizontal_advance()\fR method.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Font::FreeType,
Font::FreeType::Face
.SH AUTHOR
.IX Header "AUTHOR"
Geoff Richards <qef@laxan.com>
.SH COPYRIGHT
.IX Header "COPYRIGHT"
Copyright 2004, Geoff Richards.
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
